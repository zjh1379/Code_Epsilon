# Epsilon 长期记忆与知识图谱架构建议

## 【核心观点】

参考NagaAgent的Memory/GRAG设计对Epsilon项目**非常合适**，但需要**分阶段、轻量化实施**。当前Phase 2阶段可以先做架构准备，Phase 3再正式引入图记忆系统。

---

## 【一、对NagaAgent建议的分析】

### 1.1 值得采纳的核心设计

#### ✅ 独立Memory/GRAG模块
**价值**：记忆系统作为基础设施，而非Agent的附属功能
- **对Epsilon的意义**：
  - 当前对话历史只是内存中的临时数据，重启即丢失
  - 未来多角色、多模态Agent都需要共享记忆
  - 独立模块便于后续扩展（图像任务、项目追踪等）

#### ✅ Neo4j作为主记忆后端
**价值**：图结构天然适合表示实体关系
- **对Epsilon的意义**：
  - 用户的学习路径、项目依赖、技能图谱都是图结构
  - 比纯向量库更适合结构化记忆
  - 便于可视化展示（面试时可以展示知识图谱）

#### ✅ 分层架构（UI/服务/业务/数据）
**价值**：清晰的职责划分，便于扩展
- **对Epsilon的意义**：
  - 当前FastAPI后端已经符合这个结构
  - 只需要在业务层新增Memory模块
  - 数据层新增Neo4j，不影响现有功能

### 1.2 需要简化的部分

#### ⚠️ 多服务架构（API/Agent/MCP/TTS分离）
**建议**：Epsilon当前阶段不需要
- **原因**：
  - 当前是单用户、单后端服务
  - 多服务会增加运维复杂度
  - 可以等真正需要多Agent协作时再拆分

#### ⚠️ 完整的MCP工具集成
**建议**：先不做，专注核心记忆功能
- **原因**：
  - 当前重点是"虚拟角色+长期记忆"
  - 工具调用可以后续扩展
  - 避免过度设计

---

## 【二、Epsilon的Memory/GRAG架构设计】

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────┐
│              UI Layer (React)                   │
│  - ChatInterface                                │
│  - CharacterSwitcher                           │
│  - MemoryVisualization (未来)                   │
└──────────────────┬──────────────────────────────┘
                   │ HTTP/WebSocket
┌──────────────────▼──────────────────────────────┐
│         Service Layer (FastAPI)                 │
│  ┌──────────────────────────────────────────┐  │
│  │  API Endpoints                           │  │
│  │  - /api/chat                             │  │
│  │  - /api/memory (未来)                    │  │
│  │  - /api/graph (未来)                     │  │
│  └──────────────────────────────────────────┘  │
└──────────────────┬──────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────┐
│         Business Logic Layer                    │
│  ┌──────────────┐  ┌──────────────┐            │
│  │ LLM Service  │  │ TTS Service  │            │
│  └──────┬───────┘  └──────────────┘            │
│         │                                        │
│  ┌──────▼──────────────────────────┐            │
│  │  Memory/GRAG Service (新增)     │            │
│  │  - write_memory()               │            │
│  │  - query_memory()               │            │
│  │  - query_graph()                │            │
│  │  - extract_entities()           │            │
│  └──────┬──────────────────────────┘            │
└─────────┼───────────────────────────────────────┘
          │
┌─────────▼───────────────────────────────────────┐
│         Data Layer                              │
│  ┌──────────────┐  ┌──────────────┐            │
│  │   Neo4j      │  │  Vector DB   │            │
│  │  (Graph DB)  │  │  (可选)      │            │
│  └──────────────┘  └──────────────┘            │
│  ┌──────────────┐                              │
│  │   Memory      │                              │
│  │   (会话状态)  │                              │
│  └──────────────┘                              │
└─────────────────────────────────────────────────┘
```

### 2.2 分阶段实施计划

#### Phase 2.5（当前阶段）：架构准备
**目标**：为Memory模块做准备，不引入Neo4j

**任务**：
1. **重构对话历史管理**
   - 当前：内存中的临时列表
   - 改进：抽象为`MemoryService`接口
   - 实现：先用内存/JSON文件存储，接口设计兼容未来Neo4j

2. **设计Memory Service接口**
   ```python
   class MemoryService:
       async def write_conversation(self, user_id, messages)
       async def query_recent_context(self, user_id, limit=10)
       async def extract_entities(self, text)  # 为未来KG准备
   ```

3. **配置管理扩展**
   - 在`config.py`中添加`graph_memory`配置项（默认关闭）
   - 预留Neo4j连接配置

**时间**：1-2天
**风险**：低（不影响现有功能）

#### Phase 3：基础GraphRAG实现
**目标**：引入Neo4j，实现基础的知识图谱记忆

**任务**：
1. **Neo4j集成**
   - 安装Neo4j（本地或Docker）
   - 创建`GraphMemoryClient`封装Neo4j操作
   - 实现基础的节点/关系CRUD

2. **KG Schema设计**（针对Epsilon场景）
   ```cypher
   // 实体类型
   (User)           // 用户
   (Topic)          // 话题/领域（如"图像识别"、"Python"）
   (Project)        // 项目
   (Skill)          // 技能
   (Resource)       // 资源（文档、课程、论文）
   (Company)        // 公司（未来）
   (Position)       // 岗位（未来）
   
   // 关系类型
   (User)-[:INTERESTED_IN]->(Topic)
   (User)-[:WORKING_ON]->(Project)
   (User)-[:HAS_SKILL]->(Skill)
   (User)-[:LEARNED_FROM]->(Resource)
   (Project)-[:USES]->(Skill)
   (Project)-[:RELATED_TO]->(Topic)
   (Project)-[:REFERS_TO]->(Resource)
   ```

3. **实体抽取与写入**
   - 对话结束后，使用LLM抽取实体和关系
   - 写入Neo4j（去重、合并）
   - 实现基础的图查询

4. **记忆检索**
   - 根据当前话题查询相关实体
   - 拼接到对话上下文中

**时间**：1-2周
**风险**：中（需要设计KG schema和抽取策略）

#### Phase 4：高级GraphRAG功能
**目标**：完善记忆系统，支持复杂查询和可视化

**任务**：
1. **高级查询**
   - 用户画像查询（技能图谱、兴趣图谱）
   - 项目依赖图查询
   - 学习路径推荐

2. **记忆可视化**
   - 前端展示知识图谱
   - 交互式图探索

3. **向量库集成**（可选）
   - 文档向量化存储
   - GraphRAG + Vector RAG混合检索

**时间**：2-3周
**风险**：中（功能复杂度较高）

---

## 【三、Epsilon专属KG Schema设计】

### 3.1 实体Schema

```python
# User实体
{
    "id": "user_1",
    "name": "用户名称",
    "properties": {
        "created_at": "2025-01-XX",
        "preferred_language": "zh"
    }
}

# Topic实体
{
    "id": "topic_python",
    "name": "Python",
    "properties": {
        "category": "programming_language",
        "description": "Python编程语言"
    }
}

# Project实体
{
    "id": "project_epsilon",
    "name": "异界声律·Epsilon",
    "properties": {
        "status": "in_progress",
        "start_date": "2025-01-XX",
        "description": "虚拟角色对话系统"
    }
}

# Skill实体
{
    "id": "skill_fastapi",
    "name": "FastAPI",
    "properties": {
        "level": "intermediate",
        "category": "backend_framework"
    }
}

# Resource实体
{
    "id": "resource_paper_1",
    "name": "YOLO论文",
    "properties": {
        "type": "paper",
        "url": "...",
        "added_at": "2025-01-XX"
    }
}
```

### 3.2 关系Schema

```python
# 用户-话题关系
{
    "source": "user_1",
    "target": "topic_python",
    "type": "INTERESTED_IN",
    "properties": {
        "confidence": 0.8,
        "first_mentioned": "2025-01-XX"
    }
}

# 用户-项目关系
{
    "source": "user_1",
    "target": "project_epsilon",
    "type": "WORKING_ON",
    "properties": {
        "role": "developer",
        "start_date": "2025-01-XX"
    }
}

# 项目-技能关系
{
    "source": "project_epsilon",
    "target": "skill_fastapi",
    "type": "USES",
    "properties": {
        "importance": "high"
    }
}
```

### 3.3 Cypher查询示例

```cypher
// 查询用户的所有技能
MATCH (u:User {id: 'user_1'})-[:HAS_SKILL]->(s:Skill)
RETURN s.name, s.level

// 查询用户当前项目的依赖技能
MATCH (u:User {id: 'user_1'})-[:WORKING_ON]->(p:Project)
MATCH (p)-[:USES]->(s:Skill)
RETURN p.name, collect(s.name) as skills

// 查询与当前话题相关的项目
MATCH (t:Topic {name: '图像识别'})<-[:RELATED_TO]-(p:Project)
MATCH (p)-[:USES]->(s:Skill)
RETURN p.name, collect(s.name) as required_skills

// 查询用户的学习路径（通过资源）
MATCH (u:User {id: 'user_1'})-[:LEARNED_FROM]->(r:Resource)
MATCH (r)-[:TEACHES]->(s:Skill)
RETURN r.name, s.name
ORDER BY r.added_at
```

---

## 【四、实施建议与注意事项】

### 4.1 当前阶段（Phase 2）建议

**不建议立即引入Neo4j**，原因：
1. Phase 2目标明确（角色设定+流式语音），不应分散精力
2. 当前对话历史管理已经满足需求
3. 过早引入会增加复杂度，影响MVP稳定性

**建议做的准备**：
1. ✅ 在代码中抽象Memory接口（为未来扩展做准备）
2. ✅ 在配置文件中预留graph_memory配置项
3. ✅ 设计KG Schema（文档形式，不实现）

### 4.2 Phase 3实施时的关键决策

#### 决策1：Neo4j部署方式
- **选项A**：本地Neo4j Desktop（开发友好）
- **选项B**：Docker容器（部署方便）
- **推荐**：先用Docker，便于环境一致性

#### 决策2：实体抽取策略
- **选项A**：每次对话后自动抽取（实时）
- **选项B**：批量抽取（定时任务）
- **推荐**：先做选项A，后续优化为选项B（减少LLM调用）

#### 决策3：记忆检索时机
- **选项A**：每次对话前检索（预加载上下文）
- **选项B**：对话中按需检索（动态扩展）
- **推荐**：选项A + 选项B混合（基础上下文预加载，深度查询按需）

### 4.3 技术选型建议

#### Neo4j驱动
- **推荐**：`neo4j` Python驱动（官方，异步支持好）
- **备选**：`py2neo`（更高级的封装，但可能过重）

#### 实体抽取
- **方案A**：使用LLM直接抽取（灵活但成本高）
- **方案B**：使用NER模型（快速但可能不够准确）
- **推荐**：Phase 3先用方案A，Phase 4优化为方案B

#### 向量库（可选）
- **推荐**：`Chroma`（轻量，易于集成）
- **备选**：`pgvector`（如果已有PostgreSQL）

### 4.4 与Epsilon角色设定的结合

**重要**：Memory系统应该体现Epsilon的角色设定

1. **记忆写入时的角色视角**
   - Epsilon是"情绪核体"，记忆应该带有情感色彩
   - 记录用户情绪状态、压力点、成就感

2. **记忆检索时的角色表达**
   - 检索到的记忆应该用Epsilon的语气表达
   - "你之前提到过...""我记得你..."

3. **KG中的角色节点**
   ```cypher
   (Epsilon)-[:KNOWS_ABOUT]->(User)
   (Epsilon)-[:REMEMBERS]->(Conversation)
   (Epsilon)-[:CARES_ABOUT]->(Topic)
   ```

---

## 【五、风险与挑战】

### 5.1 技术风险

1. **Neo4j学习曲线**
   - Cypher查询语言需要学习
   - 图数据库设计需要经验
   - **缓解**：先做简单schema，逐步扩展

2. **实体抽取准确性**
   - LLM抽取可能不准确
   - 需要设计验证和纠错机制
   - **缓解**：人工审核接口，逐步优化抽取prompt

3. **性能问题**
   - 图查询可能较慢
   - 大量节点和边可能影响性能
   - **缓解**：索引优化，查询缓存

### 5.2 业务风险

1. **过度设计**
   - 可能设计过于复杂的KG schema
   - **缓解**：先做MVP，验证价值后再扩展

2. **用户隐私**
   - 长期记忆涉及用户隐私
   - **缓解**：本地部署，数据不出本地

3. **维护成本**
   - Neo4j需要维护
   - **缓解**：使用Docker，简化部署

---

## 【六、总结与下一步行动】

### 6.1 核心建议

1. **Phase 2阶段**：专注当前目标，只做架构准备
2. **Phase 3阶段**：引入Neo4j，实现基础GraphRAG
3. **Phase 4阶段**：完善功能，支持可视化

### 6.2 立即可以做的事情

1. **设计文档**
   - 完善KG Schema设计文档
   - 设计Memory Service接口文档
   - 编写Cypher查询示例

2. **代码准备**
   - 抽象Memory接口（先用内存实现）
   - 预留配置项
   - 设计数据模型

3. **技术调研**
   - 学习Neo4j基础操作
   - 研究GraphRAG最佳实践
   - 评估实体抽取方案

### 6.3 关键成功因素

1. **渐进式实施**：不要一次性引入所有功能
2. **用户价值优先**：确保每个功能都有实际价值
3. **保持简单**：避免过度设计，保持代码可维护
4. **与角色结合**：Memory系统要体现Epsilon的特色

---

**文档生成时间**: 2025-01-XX
**版本**: v1.0
**基于**: NagaAgent架构分析 + Epsilon项目现状

